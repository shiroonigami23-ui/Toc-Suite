<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TOC Help and Theory Lab</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    .help-hero {
      background: linear-gradient(120deg, #0f766e, #0ea5e9);
      color: #fff;
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 14px 28px rgba(15, 118, 110, 0.25);
    }
    .help-grid {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
    .theory-card {
      background: #fff;
      border: 1px solid #dbeafe;
      border-radius: 14px;
      padding: 14px;
    }
    .formula {
      font-family: Consolas, monospace;
      background: #eff6ff;
      border: 1px dashed #93c5fd;
      border-radius: 10px;
      padding: 10px;
      line-height: 1.5;
      overflow-x: auto;
    }
    .chip-row { display:flex; gap:8px; flex-wrap:wrap; }
    .chip-row .icon-btn { width:auto; }
    .quiz-option { display:flex; gap:8px; padding:8px; border-radius:8px; border:1px solid #e2e8f0; }
    .ok { color:#065f46; }
    .bad { color:#b91c1c; }
    .help-accordion {
      border: 1px solid #dbeafe;
      border-radius: 14px;
      background: #fff;
      margin-top: 12px;
      overflow: hidden;
    }
    .help-accordion > summary {
      cursor: pointer;
      list-style: none;
      font-weight: 700;
      padding: 14px 16px;
      background: #f8fbff;
      border-bottom: 1px solid #e5edf8;
    }
    .help-accordion > summary::-webkit-details-marker { display: none; }
    .help-accordion-content {
      padding: 14px;
    }
    .guide-hero {
      background: radial-gradient(circle at top left, #e0f2fe, #ecfeff 45%, #f8fafc 100%);
      border: 1px solid #bae6fd;
      border-radius: 14px;
      padding: 14px;
    }
    .guide-kpi-grid {
      display: grid;
      gap: 10px;
      margin-top: 10px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    .guide-kpi {
      border: 1px solid #dbeafe;
      border-radius: 10px;
      background: #ffffff;
      padding: 10px;
    }
    .guide-kpi strong {
      display: block;
      color: #0f766e;
      font-size: 1.05rem;
    }
    .guide-board {
      display: grid;
      gap: 12px;
      margin-top: 12px;
      grid-template-columns: 1fr;
    }
    .guide-block {
      border: 1px solid #dbeafe;
      border-radius: 12px;
      background: #ffffff;
      padding: 12px;
    }
    .guide-list {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 6px;
    }
    .guide-pills {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .guide-pill {
      border: 1px solid #bfdbfe;
      background: #eff6ff;
      color: #1e3a8a;
      padding: 5px 9px;
      border-radius: 999px;
      font-size: 0.82rem;
      font-weight: 600;
    }
    .guide-alert {
      margin-top: 8px;
      border-left: 4px solid #f59e0b;
      background: #fffbeb;
      color: #92400e;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <main class="app-container" style="max-width:1200px;min-height:100dvh;height:auto;">
    <header class="header">
      <h1>TOC Help and Theory Lab</h1>
      <a href="index.html" class="splash-utility-btn">Back to Menu</a>
    </header>

    <section class="help-hero">
      <h2 style="margin:0;">Learn App + Theory Together</h2>
      <p style="margin:8px 0 0 0;opacity:0.95;">This page combines studio workflows, exam-ready concepts, and dynamic formula helpers (including Arden lemma).</p>
      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
        <input id="topicSearch" class="modal-input" placeholder="Search: arden, cfg, pda, pumping, closure" style="margin:0;max-width:360px;background:#ffffff;color:#0f172a;" />
        <button id="prevTopic" class="icon-btn" type="button">Previous</button>
        <button id="nextTopic" class="icon-btn" type="button">Next</button>
        <div class="integration-status" id="topicCounter" style="margin:0;background:rgba(255,255,255,0.2);color:#fff;">Topic 1 / 1</div>
      </div>
    </section>

    <details class="help-accordion" id="help-section-tools">
      <summary>App Tool Guide</summary>
      <div class="help-accordion-content" id="tool-guide">
        <div class="guide-hero">
          <h3 style="margin:0;">Operator Playbook</h3>
          <p style="margin:8px 0 0 0;">Choose a studio and get a focused workflow, core shortcuts, and failure checks before submission.</p>
          <div class="guide-kpi-grid">
            <div class="guide-kpi"><strong>Build</strong><span>Draw machine/grammar with proper mode.</span></div>
            <div class="guide-kpi"><strong>Validate</strong><span>Run structural checker before tests.</span></div>
            <div class="guide-kpi"><strong>Test</strong><span>Single + bulk + practice checks.</span></div>
            <div class="guide-kpi"><strong>Ship</strong><span>Save JSON, export PNG, submit when required.</span></div>
          </div>
        </div>

        <div class="guide-board">
          <div class="guide-block">
            <label for="guideStudioSelect" style="font-weight:700;">Studio Playbook</label>
            <select id="guideStudioSelect" class="modal-input" style="margin-top:8px;">
              <option value="fa">Finite Automata</option>
              <option value="mm">Mealy/Moore</option>
              <option value="pda">PDA</option>
              <option value="tm">Turing Machine</option>
              <option value="grammar">Grammar Studio</option>
            </select>
            <h4 id="guideTitle" style="margin:10px 0 6px 0;">Title</h4>
            <div id="guideSummary" class="help-step-content"></div>
            <div class="guide-pills" id="guidePills"></div>
          </div>

          <div class="help-grid">
            <div class="guide-block">
              <h4 style="margin:0 0 8px 0;">Workflow Steps</h4>
              <ol id="guideSteps" class="guide-list"></ol>
            </div>
            <div class="guide-block">
              <h4 style="margin:0 0 8px 0;">Common Mistakes</h4>
              <ul id="guideMistakes" class="guide-list"></ul>
            </div>
            <div class="guide-block">
              <h4 style="margin:0 0 8px 0;">Pre-Submit Checklist</h4>
              <div id="guideChecklist" style="display:grid;gap:6px;"></div>
            </div>
          </div>

          <div class="guide-block">
            <h4 style="margin:0 0 8px 0;">Global Speed Shortcuts</h4>
            <div class="guide-pills">
              <span class="guide-pill">Ctrl/Cmd+S Save</span>
              <span class="guide-pill">Ctrl/Cmd+O Load</span>
              <span class="guide-pill">Ctrl/Cmd+E Export</span>
              <span class="guide-pill">Ctrl/Cmd+Z Undo</span>
              <span class="guide-pill">Ctrl/Cmd+Y Redo</span>
              <span class="guide-pill">V/S/T/D Tool Switch</span>
              <span class="guide-pill">Enter Run</span>
              <span class="guide-pill">Esc Clear</span>
              <span class="guide-pill">Ctrl+Alt+1 FA</span>
              <span class="guide-pill">Ctrl+Alt+2 MM</span>
              <span class="guide-pill">Ctrl+Alt+3 PDA</span>
              <span class="guide-pill">Ctrl+Alt+4 TM</span>
              <span class="guide-pill">Ctrl+Alt+5 Grammar</span>
            </div>
            <div class="guide-alert">Tip: If import looks wrong, re-import from any studio. Smart router will auto-switch to the right machine page and animate drawing.</div>
          </div>
        </div>
      </div>
    </details>

    <details class="help-accordion" id="help-section-topics">
      <summary>Topic Navigator</summary>
      <div class="help-accordion-content">
        <section class="visualization-panel">
          <div id="topicChips" class="chip-row"></div>
          <h3 id="topicTitle" style="margin-bottom:6px;">Topic</h3>
          <div id="topicBody" class="help-step-content" style="margin-bottom:10px;"></div>
          <div id="topicChecklist" style="display:grid;gap:6px;"></div>
        </section>
      </div>
    </details>

    <details class="help-accordion" id="help-section-theory">
      <summary>Theory Lab</summary>
      <div class="help-accordion-content">
    <section class="help-grid" id="theory-lab">
      <article class="theory-card">
        <h3 style="margin-top:0;">Arden Lemma Interactive</h3>
        <p>Solve equations of the form <code>R = A.R + B</code> or <code>R = R.A + B</code>.</p>
        <div class="formula">
          Arden (right-recursive): R = A.R + B => R = A*B<br />
          Arden (left-recursive): R = R.A + B => R = B.A*
        </div>
        <div style="display:grid;gap:8px;margin-top:10px;">
          <select id="ardenType" class="modal-input">
            <option value="right">R = A.R + B</option>
            <option value="left">R = R.A + B</option>
          </select>
          <input id="ardenA" class="modal-input" placeholder="A term (example: 0+1 or a)" />
          <input id="ardenB" class="modal-input" placeholder="B term (example: eps or ab)" />
          <button id="ardenSolve" class="icon-btn" type="button">Solve</button>
          <div id="ardenResult" class="integration-status">Enter A and B, then solve.</div>
        </div>
      </article>

      <article class="theory-card">
        <h3 style="margin-top:0;">Machine Recommender</h3>
        <p>Map a language/problem to the right computational model.</p>
        <select id="goalSelect" class="modal-input">
          <option value="regular">Regular language / regex-like constraints</option>
          <option value="output">Input-output transformation</option>
          <option value="stack">Nested structure / balanced symbols</option>
          <option value="grammar">CFG to machine conversion and parse tree</option>
          <option value="algorithmic">General algorithmic steps</option>
        </select>
        <div id="goalAnswer" class="help-step-content" style="margin-top:8px;"></div>
      </article>

      <article class="theory-card">
        <h3 style="margin-top:0;">Closure Property Builder</h3>
        <p>Select language family and operation to get expected closure behavior.</p>
        <select id="closureFamily" class="modal-input">
          <option value="REG">Regular</option>
          <option value="CFL">Context-Free</option>
          <option value="CSL">Context-Sensitive</option>
          <option value="RE">Recursively Enumerable</option>
        </select>
        <select id="closureOp" class="modal-input">
          <option value="union">Union</option>
          <option value="intersection">Intersection</option>
          <option value="complement">Complement</option>
          <option value="difference">Difference</option>
          <option value="concat">Concatenation</option>
          <option value="star">Kleene Star</option>
        </select>
        <button id="closureCheck" class="icon-btn" type="button">Check Closure</button>
        <div id="closureResult" class="integration-status" style="margin-top:8px;">Pick family and operation.</div>
      </article>

      <article class="theory-card">
        <h3 style="margin-top:0;">L-System Explorer</h3>
        <p>Generate formal growth strings to understand grammar rewriting systems.</p>
        <input id="lsAxiom" class="modal-input" placeholder="Axiom (example: A)" />
        <input id="lsRules" class="modal-input" placeholder="Rules (example: A->AB, B->A)" />
        <input id="lsIter" class="modal-input" placeholder="Iterations (example: 5)" />
        <button id="lsGenerate" class="icon-btn" type="button">Generate L-System</button>
        <div id="lsOutput" class="help-step-content" style="margin-top:8px;min-height:85px;"></div>
      </article>

      <article class="theory-card">
        <h3 style="margin-top:0;">LBA Boundary Practice</h3>
        <p>Quickly test if a head movement sequence stays within input bounds.</p>
        <input id="lbaInputSize" class="modal-input" placeholder="Input length n (example: 8)" />
        <input id="lbaMoves" class="modal-input" placeholder="Moves sequence (example: R,R,R,L,R)" />
        <button id="lbaCheck" class="icon-btn" type="button">Check Bound Safety</button>
        <div id="lbaOutput" class="integration-status" style="margin-top:8px;">Enter n and move sequence.</div>
      </article>
    </section>
      </div>
    </details>

    <details class="help-accordion" id="help-section-practice">
      <summary>Practice Lab</summary>
      <div class="help-accordion-content">
    <section class="help-grid">
      <article class="theory-card">
        <h3 style="margin-top:0;">Pumping Lemma Coach</h3>
        <p>Build a contradiction plan quickly for exam proofs.</p>
        <input id="pumpLanguage" class="modal-input" placeholder="Language (example: {a^n b^n | n>=0})" />
        <input id="pumpWitness" class="modal-input" placeholder="Witness w (example: a^p b^p)" />
        <input id="pumpSplit" class="modal-input" placeholder="Pick split (example: x=a^(p-k), y=a^k, z=b^p)" />
        <button id="pumpExplain" class="icon-btn" type="button">Generate Proof Skeleton</button>
        <div id="pumpResult" class="help-step-content" style="margin-top:8px;min-height:90px;"></div>
      </article>

      <article class="theory-card">
        <h3 style="margin-top:0;">CFG to PDA Checklist</h3>
        <div class="formula">q_start --eps, Z/ S Z--> q_loop<br/>q_loop --eps, A/alpha--> q_loop<br/>q_loop --a, a/eps--> q_loop<br/>q_loop --eps, Z/Z--> q_accept</div>
        <div style="display:grid;gap:6px;margin-top:10px;">
          <label><input type="checkbox" /> Push start symbol over stack marker</label>
          <label><input type="checkbox" /> Add expansion transitions for each production</label>
          <label><input type="checkbox" /> Add terminal match transitions</label>
          <label><input type="checkbox" /> Add accept transition</label>
        </div>
      </article>

      <article class="theory-card">
        <h3 style="margin-top:0;">Shortcut Trainer</h3>
        <p>Try keys: <code>Ctrl+S</code>, <code>Ctrl+E</code>, <code>V</code>, <code>T</code>, <code>D</code>, <code>Enter</code>, <code>Ctrl+Alt+1..5</code>.</p>
        <div id="shortcutOutput" class="integration-status">Waiting for key input...</div>
      </article>
    </section>
      </div>
    </details>

    <details class="help-accordion" id="help-section-quiz">
      <summary>Quiz Lab</summary>
      <div class="help-accordion-content">
        <section class="visualization-panel" id="quiz-lab">
          <h3>TOC Master Quiz</h3>
          <p id="quizQuestion" style="font-weight:700;">Question</p>
          <div id="quizOptions" style="display:grid;gap:8px;"></div>
          <div style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;">
            <button id="quizSubmit" class="icon-btn" type="button">Submit</button>
            <button id="quizNext" class="icon-btn" type="button">Next</button>
            <div id="quizScore" class="integration-status" style="margin:0;">Score 0/0</div>
          </div>
        </section>
      </div>
    </details>
  </main>

  <script>
    const HELP_KEYS = {
      topicIndex: 'tocHelpTopicIndexV2',
      quizCorrect: 'tocHelpQuizCorrectV2',
      quizTotal: 'tocHelpQuizTotalV2',
      openSections: 'tocHelpOpenSectionsV1'
    };
    const safeGet = (k, d='') => { try { return localStorage.getItem(k) ?? d; } catch (_e) { return d; } };
    const safeSet = (k, v) => { try { localStorage.setItem(k, String(v)); } catch (_e) {} };

    const topics = [
      {
        id: 'roadmap',
        title: 'TOC Roadmap: REG -> CFL -> TM',
        body: 'Start from Regular Languages (Regex, DFA/NFA), then Context-Free (CFG/PDA), then Turing Machines for general computation. Each level strictly increases expressive power.',
        checklist: ['Know what FA cannot do (a^n b^n)', 'Know PDA stack intuition', 'Know TM as full algorithm model']
      },
      {
        id: 'arden',
        title: 'Arden Lemma for Regex from Automata',
        body: 'Convert equations between states into regex. Repeatedly isolate recursive variable and apply Arden to eliminate self-reference.',
        checklist: ['Write one equation per state', 'Substitute until one variable remains', 'Apply Arden and simplify']
      },
      {
        id: 'minimization',
        title: 'DFA Minimization Logic',
        body: 'Partition states into final and non-final, then refine partitions by transition behavior until stable.',
        checklist: ['Remove unreachable states first', 'Start with coarse partition', 'Refine using transition signatures']
      },
      {
        id: 'cfg-pda',
        title: 'CFG to PDA and Parse Trees',
        body: 'Grammar Studio builds NPDA with expansion transitions and terminal-match transitions. Parse tree and leftmost derivation are generated from bounded search.',
        checklist: ['Validate grammar first', 'Review transition table', 'Test derived NPDA in PDA studio']
      },
      {
        id: 'tm-proof',
        title: 'TM Design and Correctness',
        body: 'Define tape alphabet, state invariants, and halting criteria. Validate with single-step trace and bulk tests.',
        checklist: ['Check reject path exists', 'Check boundary behavior for LBA', 'Use bulk tests as regression']
      },
      {
        id: 'complexity',
        title: 'Decidability and Reductions',
        body: 'Separate decidable, recognizable, and undecidable classes. Use mapping reductions to transfer hardness.',
        checklist: ['State source problem clearly', 'Construct computable transform', 'Prove iff relationship']
      }
    ];

    const quizBank = [
      { q: 'Arden lemma solves which type of expression?', o: ['Recursive regex equations', 'CFG ambiguity', 'PDA acceptance only'], a: 0 },
      { q: 'Language {a^n b^n} is recognized by:', o: ['DFA', 'PDA', 'Regular expression only'], a: 1 },
      { q: 'First step in DFA minimization:', o: ['Build parse tree', 'Partition by final/non-final', 'Convert to TM'], a: 1 },
      { q: 'For general algorithm simulation use:', o: ['TM Studio', 'FA only', 'Mealy only'], a: 0 },
      { q: 'CFG to NPDA key action is:', o: ['Push start symbol and apply productions on stack', 'Remove stack', 'Use only deterministic moves'], a: 0 }
    ];

    let filtered = [...topics];
    let topicIndex = Math.max(0, Number(safeGet(HELP_KEYS.topicIndex, '0')) || 0);

    const topicSearch = document.getElementById('topicSearch');
    const prevTopic = document.getElementById('prevTopic');
    const nextTopic = document.getElementById('nextTopic');
    const topicCounter = document.getElementById('topicCounter');
    const topicChips = document.getElementById('topicChips');
    const topicTitle = document.getElementById('topicTitle');
    const topicBody = document.getElementById('topicBody');
    const topicChecklist = document.getElementById('topicChecklist');
    const guideStudioSelect = document.getElementById('guideStudioSelect');
    const guideTitle = document.getElementById('guideTitle');
    const guideSummary = document.getElementById('guideSummary');
    const guidePills = document.getElementById('guidePills');
    const guideSteps = document.getElementById('guideSteps');
    const guideMistakes = document.getElementById('guideMistakes');
    const guideChecklist = document.getElementById('guideChecklist');

    const GUIDE_DATA = {
      fa: {
        title: 'Finite Automata Workflow',
        summary: 'Best for regular languages. Handle DFA/NFA/e-NFA creation, conversion, minimization, and acceptance testing.',
        pills: ['DFA/NFA/e-NFA', 'Regex-level languages', 'Fast minimization checks'],
        steps: [
          'Pick mode first: DFA, NFA, ENFA, or conversion mode.',
          'Create states and mark exactly one initial for DFA.',
          'Add transitions with complete symbol coverage.',
          'Run Validate, then single test and bulk test.',
          'Save JSON and export PNG when finalized.'
        ],
        mistakes: [
          'Missing transitions in DFA mode.',
          'Using epsilon transition in DFA mode.',
          'Unreachable states left before minimization.'
        ],
        checklist: ['Mode is correct', 'Validation green', 'Bulk test executed', 'JSON saved']
      },
      mm: {
        title: 'Mealy/Moore Workflow',
        summary: 'Use for input-output machines. Validate output trace consistency across transitions/states.',
        pills: ['Output automata', 'Trace-based grading', 'Conversion support'],
        steps: [
          'Select Moore or Mealy mode before drawing.',
          'For Moore: assign output per state.',
          'For Mealy: assign output per transition.',
          'Run I/O trace test with expected outputs.',
          'Use logic table to verify transition-output mapping.'
        ],
        mistakes: [
          'Output assigned to wrong element (state vs transition).',
          'Mode changed without re-validating outputs.',
          'Random test passing but edge trace failing.'
        ],
        checklist: ['Mode locked', 'I/O trace checked', 'Logic table reviewed', 'Saved/exported']
      },
      pda: {
        title: 'PDA Workflow',
        summary: 'Use stack logic for context-free patterns. Verify push/pop and acceptance mode behavior.',
        pills: ['Stack machine', 'CFG-linked', 'Acceptance mode aware'],
        steps: [
          'Set PDA mode and acceptance rule (final/empty/both).',
          'Build transitions with input, pop, and push fields.',
          'Use live stack visualizer during step-run.',
          'Run random and bulk tests on boundary strings.',
          'Check logic table for ambiguous stack operations.'
        ],
        mistakes: [
          'Pop symbol mismatch against expected stack top.',
          'Acceptance rule differs from intended design.',
          'Epsilon usage creates unintended branches.'
        ],
        checklist: ['Acceptance rule verified', 'Stack trace tested', 'Bulk tested', 'Saved/submitted']
      },
      tm: {
        title: 'Turing Machine Workflow',
        summary: 'Use for algorithmic computation, tape rewriting, and advanced language recognition.',
        pills: ['General computation', 'Tape operations', 'Template blocks available'],
        steps: [
          'Choose TM mode (standard, multi-tape, NTM, LBA, or block templates).',
          'Define read/write/move transitions carefully.',
          'Use Step run to inspect tape and head movement.',
          'Validate determinism and structural constraints.',
          'Run bulk tests for regression before save.'
        ],
        mistakes: [
          'Write symbol or move direction missing.',
          'LBA boundaries crossed in bounded mode.',
          'Transition loops causing timeout without halt.'
        ],
        checklist: ['Mode-specific validate pass', 'Step log inspected', 'Bulk regression done', 'JSON saved']
      },
      grammar: {
        title: 'Grammar Studio Workflow',
        summary: 'Use for CFG validation, derivation, parse tree generation, and CFG->NPDA bridge.',
        pills: ['CFG validation', 'Parse tree', 'NPDA bridge'],
        steps: [
          'Enter grammar rules and start symbol.',
          'Validate grammar and inspect symbols.',
          'Generate NPDA and review logic table.',
          'Generate parse tree and derivation timeline.',
          'Use bridge actions to open FA/PDA/TM workflows.'
        ],
        mistakes: [
          'Undefined start symbol or malformed production.',
          'Target string not derivable within depth bound.',
          'Forgetting to inspect generated NPDA transitions.'
        ],
        checklist: ['Grammar valid', 'NPDA checked', 'Parse tree generated', 'Bridge tested if needed']
      }
    };

    function renderGuide(studioKey) {
      const pack = GUIDE_DATA[studioKey] || GUIDE_DATA.fa;
      guideTitle.textContent = pack.title;
      guideSummary.textContent = pack.summary;

      guidePills.innerHTML = '';
      pack.pills.forEach((pill) => {
        const node = document.createElement('span');
        node.className = 'guide-pill';
        node.textContent = pill;
        guidePills.appendChild(node);
      });

      guideSteps.innerHTML = '';
      pack.steps.forEach((step) => {
        const li = document.createElement('li');
        li.textContent = step;
        guideSteps.appendChild(li);
      });

      guideMistakes.innerHTML = '';
      pack.mistakes.forEach((entry) => {
        const li = document.createElement('li');
        li.textContent = entry;
        guideMistakes.appendChild(li);
      });

      guideChecklist.innerHTML = '';
      pack.checklist.forEach((item) => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="checkbox" /> ${item}`;
        guideChecklist.appendChild(label);
      });
    }

    guideStudioSelect.addEventListener('change', () => renderGuide(guideStudioSelect.value));

    function renderTopicChips() {
      topicChips.innerHTML = '';
      filtered.forEach((t, idx) => {
        const b = document.createElement('button');
        b.className = 'icon-btn';
        b.type = 'button';
        b.textContent = t.title;
        if (idx === topicIndex) {
          b.style.background = 'linear-gradient(90deg,var(--accent1),var(--accent2))';
          b.style.color = '#fff';
        }
        b.addEventListener('click', () => {
          topicIndex = idx;
          renderTopic();
        });
        topicChips.appendChild(b);
      });
    }

    function renderTopic() {
      const topic = filtered[topicIndex] || filtered[0];
      if (!topic) return;
      topicTitle.textContent = topic.title;
      topicBody.textContent = topic.body;
      topicChecklist.innerHTML = '';
      topic.checklist.forEach((item) => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="checkbox" /> ${item}`;
        topicChecklist.appendChild(label);
      });
      topicCounter.textContent = `Topic ${topicIndex + 1} / ${filtered.length}`;
      prevTopic.disabled = topicIndex === 0;
      nextTopic.disabled = topicIndex >= filtered.length - 1;
      renderTopicChips();
      safeSet(HELP_KEYS.topicIndex, topicIndex);
    }

    topicSearch.addEventListener('input', () => {
      const q = topicSearch.value.trim().toLowerCase();
      filtered = topics.filter((t) => `${t.title} ${t.body} ${t.checklist.join(' ')}`.toLowerCase().includes(q));
      if (!filtered.length) filtered = [{ title: 'No match', body: 'Try another keyword.', checklist: [] }];
      topicIndex = 0;
      renderTopic();
    });

    prevTopic.addEventListener('click', () => { topicIndex = Math.max(0, topicIndex - 1); renderTopic(); });
    nextTopic.addEventListener('click', () => { topicIndex = Math.min(filtered.length - 1, topicIndex + 1); renderTopic(); });

    const goalAnswer = document.getElementById('goalAnswer');
    const goalSelect = document.getElementById('goalSelect');
    const goalMap = {
      regular: 'Use FA Studio. For regex equations and conversion, use Arden helper here.',
      output: 'Use Mealy/Moore Studio. Validate output trace against expected stream.',
      stack: 'Use PDA Studio. Good for balanced/nested constructs and CFG-linked languages.',
      grammar: 'Use Grammar Studio. Build NPDA and inspect derivation + parse tree.',
      algorithmic: 'Use TM Studio. This model can encode full algorithms and decidability experiments.'
    };
    goalSelect.addEventListener('change', () => {
      goalAnswer.textContent = goalMap[goalSelect.value] || 'Choose a problem type.';
    });
    goalSelect.dispatchEvent(new Event('change'));

    const ardenType = document.getElementById('ardenType');
    const ardenA = document.getElementById('ardenA');
    const ardenB = document.getElementById('ardenB');
    const ardenSolve = document.getElementById('ardenSolve');
    const ardenResult = document.getElementById('ardenResult');
    ardenSolve.addEventListener('click', () => {
      const A = ardenA.value.trim() || 'A';
      const B = ardenB.value.trim() || 'B';
      if (ardenType.value === 'right') {
        ardenResult.innerHTML = `<strong>R = (${A})*(${B})</strong><br/>Derived from R = ${A}.R + ${B}`;
      } else {
        ardenResult.innerHTML = `<strong>R = (${B})(${A})*</strong><br/>Derived from R = R.${A} + ${B}`;
      }
    });

    const closureCheck = document.getElementById('closureCheck');
    const closureFamily = document.getElementById('closureFamily');
    const closureOp = document.getElementById('closureOp');
    const closureResult = document.getElementById('closureResult');
    const closureTable = {
      REG: { union: true, intersection: true, complement: true, difference: true, concat: true, star: true },
      CFL: { union: true, intersection: false, complement: false, difference: false, concat: true, star: true },
      CSL: { union: true, intersection: true, complement: true, difference: true, concat: true, star: true },
      RE: { union: true, intersection: true, complement: false, difference: false, concat: true, star: true }
    };
    closureCheck.addEventListener('click', () => {
      const fam = closureFamily.value;
      const op = closureOp.value;
      const isClosed = Boolean(closureTable[fam] && closureTable[fam][op]);
      closureResult.innerHTML = isClosed
        ? `<span class="ok"><strong>${fam}</strong> is closed under <strong>${op}</strong>.</span>`
        : `<span class="bad"><strong>${fam}</strong> is not generally closed under <strong>${op}</strong>.</span>`;
    });

    const lsAxiom = document.getElementById('lsAxiom');
    const lsRules = document.getElementById('lsRules');
    const lsIter = document.getElementById('lsIter');
    const lsGenerate = document.getElementById('lsGenerate');
    const lsOutput = document.getElementById('lsOutput');
    lsGenerate.addEventListener('click', () => {
      const axiom = (lsAxiom.value || 'A').trim();
      const rulesRaw = (lsRules.value || '').trim();
      const iterations = Math.max(0, Math.min(8, Number(lsIter.value || '4')));
      const rules = {};
      rulesRaw.split(',').map((v) => v.trim()).filter(Boolean).forEach((rule) => {
        const [lhs, rhs] = rule.split('->').map((x) => x.trim());
        if (lhs && rhs !== undefined) rules[lhs] = rhs;
      });
      let current = axiom;
      const lines = [`0: ${current}`];
      for (let i = 1; i <= iterations; i += 1) {
        current = current.split('').map((ch) => rules[ch] ?? ch).join('');
        lines.push(`${i}: ${current}`);
      }
      lsOutput.innerHTML = lines.map((line) => `<div>${line}</div>`).join('');
    });

    const lbaInputSize = document.getElementById('lbaInputSize');
    const lbaMoves = document.getElementById('lbaMoves');
    const lbaCheck = document.getElementById('lbaCheck');
    const lbaOutput = document.getElementById('lbaOutput');
    lbaCheck.addEventListener('click', () => {
      const n = Number(lbaInputSize.value || '0');
      const moves = (lbaMoves.value || '').split(',').map((m) => m.trim().toUpperCase()).filter(Boolean);
      if (!Number.isFinite(n) || n <= 0) {
        lbaOutput.textContent = 'Input length must be > 0.';
        return;
      }
      let head = 0;
      let safe = true;
      for (let i = 0; i < moves.length; i += 1) {
        const m = moves[i];
        if (m === 'R') head += 1;
        if (m === 'L') head -= 1;
        if (head < 0 || head >= n) {
          safe = false;
          lbaOutput.innerHTML = `<span class="bad">Out of bound at step ${i + 1} (head=${head}). LBA rejects this run.</span>`;
          break;
        }
      }
      if (safe) {
        lbaOutput.innerHTML = `<span class="ok">Bound-safe sequence. Final head position: ${head} in [0, ${n - 1}].</span>`;
      }
    });

    const pumpExplain = document.getElementById('pumpExplain');
    const pumpLanguage = document.getElementById('pumpLanguage');
    const pumpWitness = document.getElementById('pumpWitness');
    const pumpSplit = document.getElementById('pumpSplit');
    const pumpResult = document.getElementById('pumpResult');
    pumpExplain.addEventListener('click', () => {
      const L = pumpLanguage.value.trim() || 'L';
      const w = pumpWitness.value.trim() || 'w';
      const split = pumpSplit.value.trim() || 'w = xyz';
      pumpResult.innerHTML = [
        `<strong>Goal:</strong> show ${L} is not regular (or not CFL depending on lemma).`,
        `<strong>Assume:</strong> ${L} satisfies pumping lemma with pumping length p.`,
        `<strong>Pick witness:</strong> ${w} with |w| >= p.`,
        `<strong>Any valid split:</strong> ${split}.`,
        '<strong>Pump:</strong> choose i=0 or i=2 and show pumped string exits L, contradiction.'
      ].join('<br/>');
    });

    const shortcutOutput = document.getElementById('shortcutOutput');
    document.addEventListener('keydown', (e) => {
      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target?.tagName)) return;
      const parts = [];
      if (e.ctrlKey || e.metaKey) parts.push('Ctrl/Cmd');
      if (e.altKey) parts.push('Alt');
      if (e.shiftKey) parts.push('Shift');
      parts.push(e.key.length === 1 ? e.key.toUpperCase() : e.key);
      const combo = parts.join('+').replace('Esc', 'Escape');
      const known = ['Ctrl/Cmd+S', 'Ctrl/Cmd+O', 'Ctrl/Cmd+E', 'Ctrl/Cmd+Z', 'Ctrl/Cmd+Y', 'Ctrl/Cmd+Alt+1', 'Ctrl/Cmd+Alt+2', 'Ctrl/Cmd+Alt+3', 'Ctrl/Cmd+Alt+4', 'Ctrl/Cmd+Alt+5', 'V', 'S', 'T', 'D', 'Enter', 'Escape'];
      shortcutOutput.textContent = known.includes(combo) ? `Recognized shortcut: ${combo}` : `Pressed: ${combo}`;
    });

    let quizIndex = 0;
    let quizCorrect = Number(safeGet(HELP_KEYS.quizCorrect, '0')) || 0;
    let quizTotal = Number(safeGet(HELP_KEYS.quizTotal, '0')) || 0;
    const quizQuestion = document.getElementById('quizQuestion');
    const quizOptions = document.getElementById('quizOptions');
    const quizSubmit = document.getElementById('quizSubmit');
    const quizNext = document.getElementById('quizNext');
    const quizScore = document.getElementById('quizScore');

    function renderQuiz() {
      const item = quizBank[quizIndex];
      quizQuestion.textContent = item.q;
      quizOptions.innerHTML = '';
      item.o.forEach((opt, idx) => {
        const label = document.createElement('label');
        label.className = 'quiz-option';
        label.innerHTML = `<input type="radio" name="tocQuiz" value="${idx}" /> ${opt}`;
        quizOptions.appendChild(label);
      });
      quizScore.textContent = `Score ${quizCorrect}/${quizTotal}`;
    }

    quizSubmit.addEventListener('click', () => {
      const selected = document.querySelector('input[name="tocQuiz"]:checked');
      if (!selected) {
        quizScore.textContent = `Select an answer first. Score ${quizCorrect}/${quizTotal}`;
        return;
      }
      const correct = Number(selected.value) === quizBank[quizIndex].a;
      quizTotal += 1;
      if (correct) quizCorrect += 1;
      safeSet(HELP_KEYS.quizCorrect, quizCorrect);
      safeSet(HELP_KEYS.quizTotal, quizTotal);
      quizScore.textContent = correct ? `Correct. Score ${quizCorrect}/${quizTotal}` : `Incorrect. Score ${quizCorrect}/${quizTotal}`;
    });

    quizNext.addEventListener('click', () => {
      quizIndex = (quizIndex + 1) % quizBank.length;
      renderQuiz();
    });

    if (topicIndex >= filtered.length) topicIndex = 0;
    renderTopic();
    renderQuiz();
    renderGuide(guideStudioSelect.value);

    const sectionIds = ['help-section-tools', 'help-section-topics', 'help-section-theory', 'help-section-practice', 'help-section-quiz'];
    const safeParse = (raw, fallback) => {
      try { return JSON.parse(raw); } catch (_e) { return fallback; }
    };
    const openState = safeParse(safeGet(HELP_KEYS.openSections, '{}'), {});
    sectionIds.forEach((id) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.open = Boolean(openState[id]);
      el.addEventListener('toggle', () => {
        const next = safeParse(safeGet(HELP_KEYS.openSections, '{}'), {});
        next[id] = el.open;
        safeSet(HELP_KEYS.openSections, JSON.stringify(next));
      });
    });
  </script>
</body>
</html>
